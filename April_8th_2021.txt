Today I'm starting the next chapter of my JS tutorial which will be focusing on Object-Oriented Programming. The first few exercises are mostly review:

> Creating objects
> Accessing properties of objects using dot notation.
> *** CREATING OBJECT METHODS ***

This last exercise sewed up a cognitive gap for me. I knew that methods were functions that could be applied to arrays, objects and strings, but I didn't realize that they were functions that were stored as an object PROPERTY in the object itself. This way, you can create whatever function you want in an object to be used later on that object.

>"this" keyword 

This was a bit of a grey area for me, but it's purpose is much clearer now. You can call on an object's properties using "this" in place of the object's name. This creates more flexible code, should you rename the object later on.

> Constructor functions

Constructor functions differ in a few ways from standard functions. The name of the function is capitalized, and there is no return value. Each property uses the "this" keyword and is assigned a value ending in a semi-colon.
Here is an example for future reference:

function Dog() {
  this.name = "Buddy";
  this.color = "Brindle";
  this.numLegs = 4;
}

> Creating new objects using the constructor

Define a new variable and assign it the name of the constructor with the "new" keyword. This is important, because it allows this new object to gain all the properties defined in the constructor.

let hound = new Dog();

> Extend constructors to receive arguments

This is a really cool way to make your constructors more flexible. If you know what properties you will adjust for each new object that's created, include them as arguments in the constructor function itself:

function Dog(name, color) {
  this.name = name;
  this.color = color;
  this.numLegs = 4;
}

let terrier = new Dog("Archie", "Black");


> Using "instanced" operator 

This operator checks to see if the object was created using the given constructor and returns true or false.

ex. myHouse instanceof House; ** Note that this is NOT written in camel case. **


> Understanding 'own' properties


Each object created using the constructor will have its 'own' set of properties. You can access these and list them in an array by using this "for each" loop:

function Bird(name) {
  this.name = name;
  this.numLegs = 2;
}

let canary = new Bird("Tweety");
let ownProps = [];
// Only change code below this line

for (let property in canary) {
  if (canary.hasOwnProperty(property)) {
    ownProps.push(property);
  }
}

So for each property in the object "canary", we're going to add it to the ownProps array.

> Using prototype properties

This technique helps to reduce code by creating properties that will be added to all object instances. Here's an example:

function Dog(name) {
  this.name = name;
  Dog.prototype.numLegs = 4;
}


let beagle = new Dog("Snoopy");

We know that all dogs will have four legs (in this case), so we want to automatically include that in every instance we create from then on. 

> The constructor property

Each instance of a constructor will actually have a .constructor property associated with it and can be accessed. A useful way to use it is to check to see if the instance has that property and it will return true or false:

function Dog(name) {
  this.name = name;
}

Terrier.constructor === Dog (could return true or false).

> Storing multiple prototypes as a separate object

This is a clean and efficient way to store multiple prototype properties, instead of listing each property on a separate line:

function Dog(name) {
  this.name = name;
}

Dog.prototype = {
  numLegs: 4,
  eat: function() {
    console.log("Kibble");
  },
  describe: function() {
    console.log("Super cute and soft.");
  }
};

*** REMEMBER: storing prototype properties as a separate object like this will overwrite the constructor property! Make sure you always manually add that back in:

constructor: Dog,





















